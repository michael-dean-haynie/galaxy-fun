//////////////////////////////////////////////////////////////////
// CONSTANTS
//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
// VARIABLES
//////////////////////////////////////////////////////////////////

static int selectTrainingModeDialog;

//////////////////////////////////////////////////////////////////
// FUNCTIONS
//////////////////////////////////////////////////////////////////


// static function declarations
static int hotkeyModeInt(string str);
static string hotkeyModeStr(int integer);
static void populateCellWithIconAndText (int dialog, int xOfs, int yOfs, int cellWidth, int cellHeight, string iconSrc, text cellText);
static void populateCellWithIconAndTextIndented (int dialog, int xOfs, int yOfs, int cellWidth, int cellHeight, string iconSrc, text cellText, int indentationWidth);
static void populateCellWithText (int dialog, int xOfs, int yOfs, int cellWidth, int cellHeight, text cellText);
static void createHorizontalRule(int dialog, int xOfs, int yOfs, int ruleWidth, int ruleHeight);
static text formatAccuracy(int successes, int attempts, int accuracyScore);
static text formatDelay(fixed delay, int attmepts);
static fixed getAccuracyProgress(string section);
static text formatAccuracyProgress(fixed accuracyProgress);
static fixed getDelayProgress(string section);
static text formatDelayProgress(fixed delayProgress);


void dg_hk__createSelectTrainingModeDialog() {
    int dialog;
    int dialogWidth = 500;
    int dialogHeight = 500;

    int dialogTopPadding = 40;
    int dialogLeftPadding = 40;

    int headingHeight = 30;

    int pulldownWidth = dialogWidth / 2;
    int pulldownHeight = 50;

    int racePulldown;
    int hotkeyModePulldown;

    int buttonWidth = dialogWidth / 2;
    int buttonHeight = 70;

    int runningOffsetX = 0;
    int runningOffsetY = dialogTopPadding;

    // dialog
    DialogCreate(dialogWidth, dialogHeight, c_anchorCenter, 0, 0, true);
    DialogSetVisible(DialogLastCreated(), PlayerGroupAll(), true);
    dialog = DialogLastCreated();
    selectTrainingModeDialog = dialog;

    // heading
    libNtve_gf_CreateDialogItemLabel(dialog, dialogWidth, headingHeight, c_anchorTop, runningOffsetX, runningOffsetY, StringToText("Hotkey Training"), ColorWithAlpha(0,0,0,0), false, 0.0);
    libNtve_gf_SetDialogItemStyle(DialogControlLastCreated(), "StandardTextHCentered24", PlayerGroupAll());
    DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
    runningOffsetY += headingHeight * 2;

    // race pulldown
    DialogControlCreate(dialog, c_triggerControlTypePulldown);
    racePulldown = DialogControlLastCreated();
    dg__racePulldown = racePulldown;
    DialogControlSetVisible(racePulldown, PlayerGroupAll(), true);
    DialogControlSetPosition(racePulldown, PlayerGroupAll(), c_anchorTop, runningOffsetX, runningOffsetY);
    DialogControlSetSize(racePulldown, PlayerGroupAll(), pulldownWidth, pulldownHeight);

    DialogControlAddItem(racePulldown, PlayerGroupAll(), StringToText(dg__raceName(TERRAN)));
    DialogControlAddItem(racePulldown, PlayerGroupAll(), StringToText(dg__raceName(ZERG)));
    DialogControlAddItem(racePulldown, PlayerGroupAll(), StringToText(dg__raceName(PROTOSS)));
    dg__dialogControlSelectItem(racePulldown, PlayerGroupAll(), dg__raceSelection);

    runningOffsetY += pulldownHeight;

    // hotkey mode pulldown
    DialogControlCreate(dialog, c_triggerControlTypePulldown);
    hotkeyModePulldown = DialogControlLastCreated();
    dg_hk__hotkeyModePulldown = hotkeyModePulldown;
    DialogControlSetVisible(hotkeyModePulldown, PlayerGroupAll(), true);
    DialogControlSetPosition(hotkeyModePulldown, PlayerGroupAll(), c_anchorTop, runningOffsetX, runningOffsetY);
    DialogControlSetSize(hotkeyModePulldown, PlayerGroupAll(), pulldownWidth, pulldownHeight);

    DialogControlAddItem(hotkeyModePulldown, PlayerGroupAll(), StringToText(hotkeyModeStr(dg_hk__hotkeyModeStructures)));
    DialogControlAddItem(hotkeyModePulldown, PlayerGroupAll(), StringToText(hotkeyModeStr(dg_hk__hotkeyModeProduction)));
    // DialogControlAddItem(hotkeyModePulldown, PlayerGroupAll(), StringToText(hotkeyModeStr(dg_hk__hotkeyModeAbilities)));
    // DialogControlAddItem(hotkeyModePulldown, PlayerGroupAll(), StringToText(hotkeyModeStr(dg_hk__hotkeyModeUpgrades)));
    dg__dialogControlSelectItem(hotkeyModePulldown, PlayerGroupAll(), dg_hk__hotkeyMode);

    runningOffsetY += pulldownHeight * 2;

    dg_hk_beginBtn = libNtve_gf_CreateDialogItemButton(dialog, buttonWidth, buttonHeight, c_anchorTop, runningOffsetX, runningOffsetY, StringToText(""), StringToText("Begin"), null);
}

int dg_hk__createHotkeyPromptDialog(string headingStr, text structureTxt, string iconStr)
{
    const int verticalGap = 10;
    const int dialogPadding = 40;
    const int iconSize = 76;

    int dialogWidth = 500;
    int dialogHeight = 400;

    int headingHeight = 0;
    int headingWidth = 0;

    int structureHeight = 0;
    int structureWidth = 0;

    int iconHeight = iconSize;
    int iconWidth = iconSize;

    int runningOffsetX = 0;
    int runningOffsetY = 0;

    // dialog
    DialogCreate(dialogWidth, dialogHeight, c_anchorTop, 0, 0, true);
    DialogSetVisible(DialogLastCreated(), PlayerGroupAll(), true);

    // heading label
    runningOffsetY += dialogPadding;
    headingWidth = dialogWidth;
    // headingHeight = GetLabelHeight(24);
    headingHeight = 30;
    libNtve_gf_CreateDialogItemLabel(DialogLastCreated(), headingWidth, headingHeight, c_anchorTop, runningOffsetX, runningOffsetY, StringToText(headingStr), ColorWithAlpha(0,0,0,0), false, 0.0);
    libNtve_gf_SetDialogItemStyle(DialogControlLastCreated(), "StandardTextHCentered24", PlayerGroupAll());
    DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
    runningOffsetY += headingHeight;
    runningOffsetY += (verticalGap * 3);

    // structure label
    // if (StringLength(structureTxt) > 0) {
        structureWidth = dialogWidth;
        // structureHeight = GetLabelHeight(24);
        structureHeight = 30;
        libNtve_gf_CreateDialogItemLabel(DialogLastCreated(), structureWidth, structureHeight, c_anchorTop, runningOffsetX, runningOffsetY, structureTxt, ColorWithAlpha(0,0,0,0), true, 0.5);
        libNtve_gf_SetDialogItemStyle(DialogControlLastCreated(), "StandardTextHCentered24", PlayerGroupAll());
        DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
        runningOffsetY += structureHeight;
    // }

    // icon
    if (StringLength(iconStr) > 0) {
        runningOffsetY += verticalGap;
        libNtve_gf_CreateDialogItemImage(DialogLastCreated(), iconWidth, iconHeight, c_anchorTop, runningOffsetX, runningOffsetY, StringToText(""), iconStr, c_triggerImageTypeNormal, false, Color(100,100,100), c_triggerBlendModeNormal);
        DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
        runningOffsetY += iconHeight;
    }

    // dialog
    runningOffsetY += (dialogPadding * 2);
    dialogHeight = runningOffsetY;
    DialogSetSize(DialogLastCreated(), dialogWidth, dialogHeight);

    return DialogLastCreated();
}

int dg_hk__createStructuresScoresDialog(int race) {
    int dialog;
    int cmdIdx;

    text structureText;
    string structureIconSrc;
    string structureId;

    int dialogWidth = 460;
    int dialogHeight = 875;
    int dialogBaseLeftPadding = 32;
    int dialogBaseTopPadding = 30;
    int dialogBaseBottomPadding = 25;

    int tableWidth = dialogWidth - (dialogBaseLeftPadding * 2);
    int delayColumnWidth = FixedToInt(Round(tableWidth * 0.17));
    int accuracyColumnWidth = FixedToInt(Round(tableWidth * 0.42));
    int structureColumnWidth = tableWidth - delayColumnWidth - accuracyColumnWidth;

    int headerCellHeight = 16;
    int rowCellHeight = 16;

    int modeButtonWidth = FixedToInt(tableWidth * 0.33);
    int modeButtonHeight = 50;

    int runningOffsetX = dialogBaseLeftPadding;
    int runningOffsetY = dialogBaseTopPadding;

    string targetSession;

    // single-session data variables
    int attempts;
    int failures;
    int successes;
    int accuracyScore;
    fixed delay;

    int totalAttempts;
    int totalFailures;
    int totalSuccesses;
    int totalAccuracyScore;
    fixed totalDelay;
    int totalDelayDivisor;
    fixed totalAvgDelay;

    // comparative (progress) data variables
    fixed accuracyProgress;
    fixed delayProgress;

    fixed totalAccuracyProgress;
    int totalAccuracyProgressDivisor;
    fixed totalDelayProgress;
    int totalDelayProgressDivisor;


    if (dg__scoresDialog != 0) {
        DialogDestroy(dg__scoresDialog);
    }
    DialogCreate(dialogWidth, dialogHeight, c_anchorTopRight, 0, 0, true);
    DialogSetVisible(DialogLastCreated(), PlayerGroupAll(), true);
    dialog = DialogLastCreated();
    dg__scoresDialog = dialog;

    hk_st__init(); // make sure constants have been initialized
    

    // column headers
    // column 1 header cell (Structure)
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, structureColumnWidth, headerCellHeight, null, StringToText("Structure"));
    runningOffsetX += structureColumnWidth;

    // column 2 header cell (Accuracy)
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, headerCellHeight, "Assets\\Textures\\btn-ability-terran-snipe-color.dds", StringToText("Accuracy"));
    runningOffsetX += accuracyColumnWidth;

    // column 3 header cell (Delay)
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, headerCellHeight, "Assets\\Textures\\icon-time-protoss.dds", StringToText("Delay"));
    runningOffsetX += delayColumnWidth;

    runningOffsetX = dialogBaseLeftPadding;
    runningOffsetY += headerCellHeight;

    // header line
    createHorizontalRule(dialog, runningOffsetX, runningOffsetY, tableWidth, 6);
    runningOffsetY += headerCellHeight;

    // rows
    for(cmdIdx = 0; cmdIdx < hk_st__buildHotkeyPromptCmdCount; cmdIdx += 1) {
        if (hk_st__buildHotkeyPromptHasValue(race, cmdIdx)) {
            structureIconSrc = hk_st__buildHotkeyPrompts[race][cmdIdx].abilityIconSrc;
            structureText = hk_st__buildHotkeyPrompts[race][cmdIdx].promptTargetTxt;
            structureId = hk_st__buildHotkeyPrompts[race][cmdIdx].producedUnitId;

            ////////////////////////////////////////////////
            // Structure Column (for any session target)
            ///////////////////////////////////////////////
            populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, structureColumnWidth, rowCellHeight, structureIconSrc, structureText);
            runningOffsetX += structureColumnWidth;

            // score is comparative between 2 sessions (progress)
            if (dg__scoreMode == dg__scoreModeProgress) {
                ////////////////////////////////////////
                // Accuracy Column (for progress)
                ////////////////////////////////////////

                accuracyProgress = getAccuracyProgress(bk__hotkeysStructuresPrefix + structureId);
                totalAccuracyProgress += accuracyProgress;
                totalAccuracyProgressDivisor += 1;

                populateCellWithText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, rowCellHeight, formatAccuracyProgress(accuracyProgress));
                runningOffsetX += accuracyColumnWidth;

                ////////////////////////////////////////
                // Delay Column (for progress)
                ////////////////////////////////////////

                delayProgress = getDelayProgress(bk__hotkeysStructuresPrefix + structureId);
                totalDelayProgress += delayProgress;
                totalDelayProgressDivisor += 1;

                populateCellWithText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, rowCellHeight, formatDelayProgress(delayProgress));
                runningOffsetX += delayColumnWidth;
            }

            // score is a for a particular session
            else {

                // figure out the latest session with attempts
                if (dg__scoreMode == dg__scoreModeLatest) {
                    targetSession = bk__currentSession;
                    attempts = bk__getValueAsInt(bk__hotkeysStructuresPrefix + structureId, bk__currentSessionAttempts);
                    if (attempts == 0 && dg__inSession == false) { // when not inSession, sub in data from the most recent session
                        targetSession = bk__mostRecentSession;
                        attempts = bk__getValueAsInt(bk__hotkeysStructuresPrefix + structureId, bk__mostRecentSessionAttempts);
                    }
                }

                // go straight to alltime data
                if (dg__scoreMode == dg__scoreModeAllTime) {
                    targetSession = bk__allTime;
                    attempts = bk__getValueAsInt(bk__hotkeysStructuresPrefix + structureId, bk__allTimeAttempts);
                }

                totalAttempts += attempts;

                failures = bk__getValueAsInt(bk__hotkeysStructuresPrefix + structureId, targetSession + bk__failures);
                totalFailures += failures;

                delay = bk__getValueAsFixed(bk__hotkeysStructuresPrefix + structureId, targetSession + bk__delay);
                if (delay > 0) {
                    totalDelay += delay;
                    totalDelayDivisor += 1;
                }

                successes = attempts - failures;
                totalSuccesses += successes;

                ////////////////////////////////////////
                // Accuracy Column (for latest session)
                ////////////////////////////////////////
                accuracyScore = 100;
                if (attempts > 0) {
                    accuracyScore = FixedToInt(Round((IntToFixed(successes) / IntToFixed(attempts)) * 100));
                }

                // full-width example: "100% (999999/999999)"
                populateCellWithText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, rowCellHeight, formatAccuracy(successes, attempts, accuracyScore));
                runningOffsetX += accuracyColumnWidth;

                ////////////////////////////////////////
                // Delay Column (for latest session)
                ////////////////////////////////////////

                // full-width example: "99.99s"
                populateCellWithText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, rowCellHeight, formatDelay(delay, successes));
                runningOffsetX += delayColumnWidth;
            }

            runningOffsetY += rowCellHeight;
            runningOffsetX = dialogBaseLeftPadding;
        }
    }

    // bottom line
    createHorizontalRule(dialog, runningOffsetX, runningOffsetY, tableWidth, 4);
    runningOffsetY += headerCellHeight;

    // Structure column
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, structureColumnWidth, rowCellHeight, null, StringToText("Overall"));
    runningOffsetX += structureColumnWidth;

    // score is comparative between 2 sessions (progress)
    if (dg__scoreMode == dg__scoreModeProgress) {
        // Accuracy column
        populateCellWithText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, rowCellHeight, formatAccuracyProgress(totalAccuracyProgress / totalAccuracyProgressDivisor));
        runningOffsetX += accuracyColumnWidth;

        // DelayColumn
        // full-width example: "99.99s"
        populateCellWithText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, rowCellHeight, formatDelayProgress(totalDelayProgress / totalDelayProgressDivisor));
        runningOffsetX += delayColumnWidth;
    }

    // score is a for a particular session
    else {
        // Accuracy column
        totalAccuracyScore = 100;
        if (totalAttempts > 0) {
            totalAccuracyScore = FixedToInt(Round((IntToFixed(totalSuccesses) / IntToFixed(totalAttempts)) * 100));
        }

        // full-width example: "100% (999999/999999)"
        populateCellWithText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, rowCellHeight, formatAccuracy(totalSuccesses, totalAttempts, totalAccuracyScore));
        runningOffsetX += accuracyColumnWidth;

        // Delay column
        if (totalSuccesses > 0) {
            totalAvgDelay = totalDelay / totalDelayDivisor;
        }

        // full-width example: "99.99s"
        populateCellWithText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, rowCellHeight, formatDelay(totalAvgDelay, totalSuccesses));
        runningOffsetX += delayColumnWidth;
    }



    // bottom buttons
    runningOffsetY = dialogBaseBottomPadding;
    runningOffsetX = dialogBaseLeftPadding;

    dg__scoreModeLatestBtn = libNtve_gf_CreateDialogItemButton(dialog, modeButtonWidth, modeButtonHeight, c_anchorBottomLeft, runningOffsetX, runningOffsetY, StringToText(""), StringToText("Latest"), null);
    if (dg__scoreMode == dg__scoreModeLatest) {
        libNtve_gf_SetDialogItemToggled(DialogControlLastCreated(), true, (PlayerGroupAll()));
    }
    runningOffsetX += modeButtonWidth;

    dg__scoreModeProgressBtn = libNtve_gf_CreateDialogItemButton(dialog, modeButtonWidth, modeButtonHeight, c_anchorBottomLeft, runningOffsetX, runningOffsetY, StringToText(""), StringToText("Progress"), null);
    if (dg__scoreMode == dg__scoreModeProgress) {
        libNtve_gf_SetDialogItemToggled(DialogControlLastCreated(), true, (PlayerGroupAll()));
    }
    runningOffsetX += modeButtonWidth;

    dg__scoreModeAllTimeBtn = libNtve_gf_CreateDialogItemButton(dialog, modeButtonWidth, modeButtonHeight, c_anchorBottomLeft, runningOffsetX, runningOffsetY, StringToText(""), StringToText("All Time"), null);
    if (dg__scoreMode == dg__scoreModeAllTime) {
        libNtve_gf_SetDialogItemToggled(DialogControlLastCreated(), true, (PlayerGroupAll()));
    }
    runningOffsetX += modeButtonWidth;


    return DialogLastCreated();
}

int dg_hk__createProductionScoresDialog(int race) {
    int dialog;
    int casterIdx;
    int cmdIdx;

    string casterUnitIconSrc;
    text casterUnitTxt;
    string casterUnitId;

    string trainedUnitIconSrc;
    text trainedUnitTxt;
    string trainedUnitId;

    int dialogWidth = 460;
    int dialogHeight = 875;
    int dialogBaseLeftPadding = 32;
    int dialogBaseTopPadding = 30;
    int dialogBaseBottomPadding = 25;

    int tableWidth = dialogWidth - (dialogBaseLeftPadding * 2);
    int delayColumnWidth = FixedToInt(Round(tableWidth * 0.17));
    int accuracyColumnWidth = FixedToInt(Round(tableWidth * 0.42));
    int unitColumnWidth = tableWidth - delayColumnWidth - accuracyColumnWidth;
    bool casterRowCreated;

    int headerCellHeight = 16;
    int rowCellHeight = 16;
    int indentationWidth = rowCellHeight; // so it will be the same as the icon width;

    int modeButtonWidth = FixedToInt(tableWidth * 0.33);
    int modeButtonHeight = 50;

    int runningOffsetX = dialogBaseLeftPadding;
    int runningOffsetY = dialogBaseTopPadding;

    string targetSession;

    int attempts;
    int failures;
    int successes;
    int accuracyScore;
    fixed delay;

    int totalAttempts;
    int totalFailures;
    int totalSuccesses;
    int totalAccuracyScore;
    fixed totalDelay;
    int totalDelayDivisor;
    fixed totalAvgDelay;

    if (dg__scoresDialog != 0) {
        DialogDestroy(dg__scoresDialog);
    }
    DialogCreate(dialogWidth, dialogHeight, c_anchorTopRight, 0, 0, true);
    DialogSetVisible(DialogLastCreated(), PlayerGroupAll(), true);
    dialog = DialogLastCreated();
    dg__scoresDialog = dialog;

    hk_pd__init(); // make sure constants have been initialized

    // column headers
    // column 1 header cell (Unit)
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, unitColumnWidth, headerCellHeight, null, StringToText("Unit"));
    runningOffsetX += unitColumnWidth;

    // column 2 header cell (Accuracy)
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, headerCellHeight, "Assets\\Textures\\btn-ability-terran-snipe-color.dds", StringToText("Accuracy"));
    runningOffsetX += accuracyColumnWidth;

    // column 3 header cell (Delay)
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, headerCellHeight, "Assets\\Textures\\icon-time-protoss.dds", StringToText("Delay"));
    runningOffsetX += delayColumnWidth;

    runningOffsetX = dialogBaseLeftPadding;
    runningOffsetY += headerCellHeight;

    // header line
    createHorizontalRule(dialog, runningOffsetX, runningOffsetY, tableWidth, 6);
    runningOffsetY += headerCellHeight;

    // rows
    for(casterIdx = 0; casterIdx < hk_pd__castersSize; casterIdx += 1) {
        casterRowCreated = false;
        if(hk_pd__castersElementHasValue(race, casterIdx)) {
            for(cmdIdx = 0; cmdIdx < hk_pd__promptsSize; cmdIdx += 1) {
                if (hk_pd__promptsElementHasValue(race, casterIdx, cmdIdx)) {
                    casterUnitIconSrc = hk_pd__prompts[race][casterIdx][cmdIdx].casterUnitIconSrc;
                    casterUnitTxt = hk_pd__prompts[race][casterIdx][cmdIdx].casterUnitTxt;
                    casterUnitId = hk_pd__prompts[race][casterIdx][cmdIdx].casterUnitId;

                    trainedUnitIconSrc = hk_pd__prompts[race][casterIdx][cmdIdx].abilityIconSrc;
                    trainedUnitTxt = hk_pd__prompts[race][casterIdx][cmdIdx].promptTargetTxt;
                    trainedUnitId = hk_pd__prompts[race][casterIdx][cmdIdx].producedUnitId;

                    // Unit column
                    if (!casterRowCreated){
                        populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, unitColumnWidth, rowCellHeight, casterUnitIconSrc, casterUnitTxt);
                        runningOffsetY += rowCellHeight;
                        casterRowCreated = true;
                    }
                    populateCellWithIconAndTextIndented(dialog, runningOffsetX, runningOffsetY, unitColumnWidth, rowCellHeight, trainedUnitIconSrc, trainedUnitTxt, indentationWidth);
                    runningOffsetX += unitColumnWidth;

                    // Accuracy column
                    attempts = bk__getValueAsInt(bk__hotkeysProductionPrefix + trainedUnitId, bk__currentSessionAttempts);
                    totalAttempts += attempts;
                    failures = bk__getValueAsInt(bk__hotkeysProductionPrefix + trainedUnitId, bk__currentSessionFailures);
                    totalFailures += failures;
                    successes = attempts - failures;
                    totalSuccesses += successes;
                    accuracyScore = 100;
                    if (attempts > 0) {
                        accuracyScore = FixedToInt(Round((IntToFixed(successes) / IntToFixed(attempts)) * 100));
                    }

                    // full-width example: "100% (999999/999999)"
                    populateCellWithText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, rowCellHeight, formatAccuracy(successes, attempts, accuracyScore));
                    runningOffsetX += accuracyColumnWidth;

                    // Delay column
                    delay = bk__getValueAsFixed(bk__hotkeysProductionPrefix + trainedUnitId, bk__currentSessionDelay);
                    totalDelay += delay;

                    // full-width example: "99.99s"
                    populateCellWithText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, rowCellHeight, formatDelay(delay, successes));
                    runningOffsetX += delayColumnWidth;

                    runningOffsetY += rowCellHeight;
                    runningOffsetX = dialogBaseLeftPadding;
                }
            }
        }
    }

    // bottom line
    createHorizontalRule(dialog, runningOffsetX, runningOffsetY, tableWidth, 4);
    runningOffsetY += headerCellHeight;

    // Structure column
    populateCellWithIconAndText(dialog, runningOffsetX, runningOffsetY, unitColumnWidth, rowCellHeight, null, StringToText("Overall"));
    runningOffsetX += unitColumnWidth;

    // Accuracy column
    totalAccuracyScore = 100;
    if (totalAttempts > 0) {
        totalAccuracyScore = FixedToInt(Round((IntToFixed(totalSuccesses) / IntToFixed(totalAttempts)) * 100));
    }

    // full-width example: "100% (999999/999999)"
    populateCellWithText(dialog, runningOffsetX, runningOffsetY, accuracyColumnWidth, rowCellHeight, formatAccuracy(totalSuccesses, totalAttempts, totalAccuracyScore));
    runningOffsetX += accuracyColumnWidth;

    // Delay column
    if (totalSuccesses > 0) {
        totalAvgDelay = totalDelay / totalSuccesses;
    }

    // full-width example: "99.99s"
    populateCellWithText(dialog, runningOffsetX, runningOffsetY, delayColumnWidth, rowCellHeight, formatDelay(totalAvgDelay, totalSuccesses));
    runningOffsetX += delayColumnWidth;


    // bottom buttons
    runningOffsetY = dialogBaseBottomPadding;
    runningOffsetX = dialogBaseLeftPadding;

    dg__scoreModeLatestBtn = libNtve_gf_CreateDialogItemButton(dialog, modeButtonWidth, modeButtonHeight, c_anchorBottomLeft, runningOffsetX, runningOffsetY, StringToText(""), StringToText("Latest"), null);
    if (dg__scoreMode == dg__scoreModeLatest) {
        libNtve_gf_SetDialogItemToggled(DialogControlLastCreated(), true, (PlayerGroupAll()));
    }
    runningOffsetX += modeButtonWidth;

    dg__scoreModeProgressBtn = libNtve_gf_CreateDialogItemButton(dialog, modeButtonWidth, modeButtonHeight, c_anchorBottomLeft, runningOffsetX, runningOffsetY, StringToText(""), StringToText("Progress"), null);
    if (dg__scoreMode == dg__scoreModeProgress) {
        libNtve_gf_SetDialogItemToggled(DialogControlLastCreated(), true, (PlayerGroupAll()));
    }
    runningOffsetX += modeButtonWidth;

    dg__scoreModeAllTimeBtn = libNtve_gf_CreateDialogItemButton(dialog, modeButtonWidth, modeButtonHeight, c_anchorBottomLeft, runningOffsetX, runningOffsetY, StringToText(""), StringToText("All Time"), null);
    if (dg__scoreMode == dg__scoreModeAllTime) {
        libNtve_gf_SetDialogItemToggled(DialogControlLastCreated(), true, (PlayerGroupAll()));
    }
    runningOffsetX += modeButtonWidth;


    return DialogLastCreated();
}

void dg_hk__onSelectionChangedHotkeyModePulldown(int dialogCtrlId) {
    int selectedIndex = DialogControlGetSelectedItem(dialogCtrlId, 1);
    dg_hk__hotkeyMode = selectedIndex - 1; // items are 1 indexed, races are 0 indexed

    if (dg__trainingArea == dg__trainingAreaHotkeys) {
        if (dg_hk__hotkeyMode == dg_hk__hotkeyModeStructures) {
            dg_hk__createStructuresScoresDialog(dg__raceSelection);
        }
        if (dg_hk__hotkeyMode == dg_hk__hotkeyModeProduction) {
            dg_hk__createProductionScoresDialog(dg__raceSelection);
        }
    }
}

void dg_hk__onClickBeginBtn() {
    DialogDestroy(selectTrainingModeDialog);

    if (dg_hk__hotkeyMode == dg_hk__hotkeyModeStructures){
        hk_st__begin(dg__raceSelection);
    }
    if (dg_hk__hotkeyMode == dg_hk__hotkeyModeProduction){
        hk_pd__begin(dg__raceSelection);
    }
}

static void populateCellWithIconAndText (int dialog, int xOfs, int yOfs, int cellWidth, int cellHeight, string iconSrc, text cellText) {
    int iconWidth = cellHeight;
    int iconHeight = cellHeight;

    int textWidth = cellWidth - iconWidth;
    int textHeight = cellHeight;

    int runningOffsetX = xOfs;
    int runningOffsetY = yOfs;

    int paddingBetweenIconAndText = 3;

    // icon
    if (iconSrc != null) {
        libNtve_gf_CreateDialogItemImage(dialog, iconWidth, iconHeight, c_anchorTopLeft, runningOffsetX, runningOffsetY, StringToText(""), iconSrc, c_triggerImageTypeNormal, false, Color(100,100,100), c_triggerBlendModeNormal);
        DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
    }
    runningOffsetX += iconWidth + paddingBetweenIconAndText;

    // cell text
    libNtve_gf_CreateDialogItemLabel(DialogLastCreated(), textWidth, textHeight, c_anchorTopLeft, runningOffsetX, runningOffsetY, cellText, ColorWithAlpha(0,0,0,0), false, 0.0);
    libNtve_gf_SetDialogItemStyle(DialogControlLastCreated(), "StandardText12", PlayerGroupAll());
    DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
}

static void populateCellWithIconAndTextIndented (int dialog, int xOfs, int yOfs, int cellWidth, int cellHeight, string iconSrc, text cellText, int indentationWidth) {
    int indentedXOfs = xOfs + indentationWidth;
    int indentedCellWidth = cellWidth - indentationWidth;

    populateCellWithIconAndText (dialog, indentedXOfs, yOfs, indentedCellWidth, cellHeight, iconSrc, cellText);
}

static void populateCellWithText (int dialog, int xOfs, int yOfs, int cellWidth, int cellHeight, text cellText) {
    int iconWidth = cellHeight;
    int iconHeight = cellHeight;

    int textWidth = cellWidth - iconWidth;
    int textHeight = cellHeight;

    int runningOffsetX = xOfs;
    int runningOffsetY = yOfs;

    // cell text
    libNtve_gf_CreateDialogItemLabel(DialogLastCreated(), textWidth, textHeight, c_anchorTopLeft, runningOffsetX, runningOffsetY, cellText, ColorWithAlpha(0,0,0,0), false, 0.0);
    libNtve_gf_SetDialogItemStyle(DialogControlLastCreated(), "StandardText12", PlayerGroupAll());
    DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
}

static void createHorizontalRule(int dialog, int xOfs, int yOfs, int ruleWidth, int ruleHeight) {
    string imgSrc = "Assets\\Textures\\sc2_ui_glues_scorescreen_graphline_01.dds"; // 12x12
    libNtve_gf_CreateDialogItemImage(dialog, ruleWidth, ruleHeight, c_anchorTopLeft, xOfs, yOfs, StringToText(""), imgSrc, c_triggerImageTypeNormal, true, Color(100,100,100), c_triggerBlendModeNormal);
    DialogControlSetVisible(DialogControlLastCreated(), PlayerGroupAll(), true);
}

static text formatAccuracy(int successes, int attempts, int accuracyScore) {
    string successesStr = IntToString(successes);
    int successesStrLn = StringLength(successesStr);

    string attemptsStr = IntToString(attempts);
    int attemptsStrLn = StringLength(attemptsStr);

    string accuracyScoreStr;
    int accuracyScoreStrLn;


    int i;
    
    for (i = successesStrLn; i < 4; i += 1) {
        successesStr = "_" + successesStr;
    }

    for (i = attemptsStrLn; i < 4; i += 1) {
        attemptsStr = attemptsStr + "_";
    }

    if (attempts > 0)  {
        accuracyScoreStr = IntToString(accuracyScore);
    }
    else {
        accuracyScoreStr = "";
    }
    accuracyScoreStrLn = StringLength(accuracyScoreStr);

    for (i = accuracyScoreStrLn; i < 3; i += 1) {
        accuracyScoreStr = "_" + accuracyScoreStr;
    }

    return StringToText(accuracyScoreStr + "% ("  + successesStr + "/" + attemptsStr + ")");
}

static text formatDelay(fixed delay, int successes) {
    string delayStr = FixedToString(delay, 2);

    if (successes < 1) {
        return StringToText("-----");
    }

    if (StringFind(delayStr, ".", false) < 3) {
        delayStr = "_" + delayStr + "s";
    }

    return StringToText(delayStr);
}

fixed getAccuracyProgress(string section) {
    fixed currentAttempts = IntToFixed(bk__getValueAsInt(section, bk__currentSession + bk__attempts));
    fixed currentFailures = IntToFixed(bk__getValueAsInt(section, bk__currentSession + bk__failures));
    fixed currentSuccesses = currentAttempts - currentFailures;
    fixed mostRecentAttempts = IntToFixed(bk__getValueAsInt(section, bk__mostRecentSession + bk__attempts));
    fixed mostRecentFailures = IntToFixed(bk__getValueAsInt(section, bk__mostRecentSession + bk__failures));
    fixed mostRecentSuccesses = mostRecentAttempts - mostRecentFailures;

    if (currentAttempts == 0 || mostRecentAttempts == 0) {
        return 0.0; // no progress could be calculated
    }

    return (currentSuccesses / currentAttempts) - (mostRecentSuccesses / mostRecentAttempts);
}

static text formatAccuracyProgress(fixed accuracyProgress) {
    string pctgStr;
    int i;
    string polarity = "+";

    if (accuracyProgress == 0.0) {
        return StringToText("-----");
    }

    if (accuracyProgress < 0) {
        accuracyProgress = accuracyProgress * -1; // make it positive, will concatenate polarity sign later
        polarity = "-";
    }

    pctgStr = FixedToString(accuracyProgress * 100, 0);
    for(i = StringLength(pctgStr); i < 3; i += 1) {
        pctgStr = " " + pctgStr;
    }

    return StringToText(polarity + pctgStr + "%");
}

fixed getDelayProgress(string section) {
    fixed currentDelay = bk__getValueAsFixed(section, bk__currentSession + bk__delay);
    fixed mostRecentDelay = bk__getValueAsFixed(section, bk__mostRecentSession + bk__delay);

    if (currentDelay == 0 || mostRecentDelay == 0) {
        return 0.0; // no progress could be calculated
    }

    return (currentDelay) - (mostRecentDelay);
}

static text formatDelayProgress(fixed delayProgress) {
    string delayStr;
    int i;
    string polarity = "+";

    if (delayProgress == 0.0) {
        return StringToText("-----");
    }

    if (delayProgress < 0) {
        delayProgress = delayProgress * -1; // make it positive, will concatenate polarity sign later
        polarity = "-";
    }

    delayStr = FixedToString(delayProgress, 2);
    for(i = StringLength(delayStr); i < 5; i += 1) {
        delayStr = " " + delayStr;
    }

    return StringToText(polarity + delayStr + "s");
}

static int hotkeyModeInt(string str) {
    if (str == "Structures") {
        return 0;
    }
    if (str == "Unit Production") {
        return 0;
    }
    if (str == "Abilities") {
        return 0;
    }
    if (str == "Upgrades/Research") {
        return 0;
    }
    return -1;
}

static string hotkeyModeStr(int integer) {
    if (integer == 0) {
        return "Structures";
    }
    if (integer == 1) {
        return "Unit Production";
    }
    if (integer == 2) {
        return "Abilities";
    }
    if (integer == 3) {
        return "Upgrades/Research";
    }
    return null;
}

//////////////////////////////////////////////////////////////////
// Initialization
//////////////////////////////////////////////////////////////////

void dg_hk__init() {}